# spring问题点详解

## IOC 依赖注入

### @Autowired 的区别 @Resource

1. @Autowired 优先按照 @Qualifier 指定的名称进行装配，在没有指定 @Qualifier 的时候，默认按照类的名称进行装配，然后再按照属性名称进行装配。
2. @Resource 先按照属性名称进行装配，然后如果存在 @Qualifier 指定的名称，则按照 @Qualifier 指定的名称进行装配，如果不存在 @Qualifier 再按照类的名称进行装配。
3. @Resource 因为是先按照名称匹配，再按照类名匹配，所以会存在一个问题：名称如果匹配成功，然而类名和名称对应的类不是同一个的时候，会报错。

## AOP 切面编程

> <font color="red">**优先使用JDK自己的动态代理，如果发现要代理的对象没有接口时，会使用Cglib的动态代理**</font>

### JDK自己的动态代理（只能代理有接口的实现类）

### Cjlib 可以代理所有的类

### 执行顺序

1. 正常执行：@Before--->@After--->@AfterReturning
2. 异常执行：@Before--->@After--->@AfterThrowing

#### 环绕通知的执行顺序

1. 正常执行：环绕前置(方法执行前)-->普通前置(方法执行前)@Before-->目标方法执行-->环绕后置(方法执行后)-->环绕最终返回-->普通后置(方法执行后)@After-->普通最终返回@AfterReturning。
2. 异常执行：环绕前置(方法执行前)-->普通前置(方法执行前)@Before-->目标方法执行-->环绕执行异常-->环绕最终返回-->普通后置(方法执行后)@After-->普通执行异常@AfterThrowing。

环绕@Before-->普通前置@Before-->目标方法执行-->环绕正常结束/出现异常-->环绕后置-->普通后置-->普通返回或者异常。

## transactionManager 事务管理

### 事务的处理

1. 正常的事务提交(commit)或者回滚(rollback)
2. 自动提交，但是一般情况下要将自动提交进行关闭，影响效率
3. 用户关闭会话，会自动提交事务
4. 系统崩溃或者断电的时候，自动回滚事务
5. 当一次执行多条sql（同时包含DML语句和DDL语句）时，当在执行DDL语句之前，会自动提交事务，所以当遇到这种情况时，应当把DDL语句放在最后执行。
6. sql分类：
   1. DML 数据操控:如select,insert,update,delete
   2. DCL 数据控制:如权限控制，grant,revoke
   3. DDL 数据定义:如create,alter,drop等表定义语句
   
### 事务的基本特性

> 事务的基本特性<font color="red">ACID</font>：
>
> 1. **原子性（Atomicity）**：一个原子事务要么完整执行，要么干脆不执行。这意味着，工作单元中的每项任务都必须正确执行。如果有任一任务执行失败，则整个工作单元或事务就会被终止。即此前对数据所作的任何修改都将被撤销。如果所有任务都被成功执行，事务就会被提交，即对数据所作的修改将会是永久性的。
> 2. **一致性（Consistency）**：一致性代表了底层数据存储的完整性。它必须由事务系统和应用开发人员共同来保证。事务系统通过保证事务的原子性，隔离性和持久性来满足这一要求; 应用开发人员则需要保证数据库有适当的约束(主键，引用完整性等)，并且工作单元中所实现的业务逻辑不会导致数据的不一致(即，数据预期所表达的现实业务情况不相一致)。例如，在一次转账过程中，从某一账户中扣除的金额必须与另一账户中存入的金额相等。支付宝账号100 你读到余额要取，有人向你转100 但是事物没提交（这时候你读到的余额应该是100，而不是200） 这种就是一致性。
> 3. **隔离性（Isolation）**：隔离性意味着事务必须在不干扰其他进程或事务的前提下独立执行。换言之，在事务或工作单元执行完毕之前，其所访问的数据不能受系统其他部分的影响。
> 4. **持久性（Durability）**：持久性表示在某个事务的执行过程中，对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。这样可以保证，所作的修改在任何系统瘫痪时不至于丢失。

### 隔离级别

>1. **脏读**
>
>**所谓脏读，就是指事务A读到了事务B还没有提交的数据**，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务-->取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读。
>
>2. **不可重复读**
>
>所谓不可重复读，就是指**在一个事务里面读取了两次某个数据，读出来的数据不一致**。还是以银行取钱为例，事务A开启事务-->查出银行卡余额为1000元，此时切换到事务B事务B开启事务-->事务B取走100元-->提交，数据库里面余额变为900元，此时切换回事务A，事务A再查一次查出账户余额为900元，这样对事务A而言，在同一个事务内两次读取账户余额数据不一致，这就是不可重复读。
>
>3. **幻读**
>
>所谓幻读，就是指**在一个事务里面的操作中发现了未被操作的数据**。比如学生信息，事务A开启事务-->修改所有学生当天签到状况为false，此时切换到事务B，事务B开启事务-->事务B插入了一条学生数据，此时切换回事务A，事务A提交的时候发现了一条自己没有修改过的数据，这就是幻读，就好像发生了幻觉一样。幻读出现的前提是并发的事务中有事务发生了插入、删除操作。

| MySQL的事务隔离级别：默认可重复读 | 脏读 | 不可重复读 | 幻读 |
| --------------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted）      | 是   | 是         | 是   |
| 读已提交（read-committed）        | 否   | 是         | 是   |
| 可重复读（repeatable-read）       | 否   | 否         | 是   |
| 序列化（serializable）            | 否   | 否         | 否   |

| Oracle的事务隔离级别:默认读已提交 | 脏读 | 不可重复读 | 幻读 |
| --------------------------------- | ---- | ---------- | ---- |
| 读已提交（read-committed）        | 否   | 是         | 是   |
| 只读（read only）                 | 否   | 否         | 是   |
| 序列化（serializable）            | 否   | 否         | 否   |



### 传播特性

1. REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是默认的。
2. REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。
3. SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。
4. NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
5. MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。
6. NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。
7. NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。

> 1.REQUIRED
>
> 1.1 REQUIRED
>
> 1.2 REQUIRED
>
> 三个方法在一个事务里面执行，全部正常则提交，只要有一个出现异常所有全部回滚

> 1.无事务
>
> 1.1 REQUIRED 出现异常
>
> 1.2 REQUIRED 
>
> 1.1和1.2在两个单独的事务里面执行。谁报错谁回滚，谁不报错谁提交

> 1.REQUIRED
>
> 1.1 REQUIRES_NEW （独立的事务）
>
> 1.2 REQUIRED （和父方法在一个事务里）
>
> 1和1.2共用一个事务，1.1报错回滚，外面的事务能监测到异常，故外面的事务也会进行回滚
>
> 1和1.2共用一个事务，1.2报错回滚，1.1执行正常则不会回滚

> 1.REQUIRED
>
> 1.1 REQUIRES_NEW （独立的事务）
>
> 1.2 REQUIRES_NEW （独立的事务）
>
> 每一个方法都是一个独立的事务，谁报错谁回滚，谁不报错谁提交

> 1. REQUIRED
>
> 1.1 SUPPORTS
>
> 运行在一个事务里，全部正常则提交，只要有一个出现异常所有全部回滚

> 1.无事务
>
> 1.1 SUPPORTS
>
> 不运行在事务里，成功的成功，失败的失败，不会回滚，数据可能会不一致

> 1.REQUIRED
>
> 1.1 NOT_SUPPORTED
>
> 虽然运行在事务里，但是不受事务的控制，成功的成功，失败的失败，不会回滚，数据可能会不一致

> 1.REQUIRED
>
> 1.1 NEVER（不能运行在事务里，如果有事务，则抛出异常）
>
> 抛出异常

> 1.无事务
>
> 1.1 MANDATORY （必须运行在事务里，如果没有事务，则抛出异常）
>
> 抛出异常

> 1.REQUIRED
>
> 1.1 NESTED（会创建一个嵌套的事务）
>
> 1.2 REQUIRED
>
> 1和1.2共用一个事务，1.1报错回滚，嵌套的子事务不会影响外面的事务，故外面的不会回滚
>
> 1和1.2共用一个事务，1.2报错回滚，影响到了嵌套的子事务，故子事务也会回滚